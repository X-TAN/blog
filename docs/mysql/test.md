#### 基本MySQL指南

特点：
- 本质是关系型数据库，mysql8加入了NoSql支持
- 开源软件
- 默认端口3306
- 关键参数可以提升MySQL对应性能，[MySQL5.7参数简单说明](https://blog.csdn.net/u014609263/article/details/96675607)，[简单5.7调优指南](https://www.21cto.com/article/1621)

> 存储引擎

查看MySQL提供的所有存储引擎：
```shell
mysql> show engines;
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
9 rows in set (0.00 sec)
```

在这个上面显示出来```InnoDB```是默认支持的存储引擎，主要支持的特性有：
- 支持事物，行锁设计，支持非锁定读。
- 使用多版本并发控制(MVCC)来获得并发性。
- 实现了 SQL 的四种隔离级别，默认是 REPEATABLE。
- 使用 next-key-locking 策略来避免幻读现象产生。
- 提供了插入缓存，二次写，自适应哈希索引，预读等高性能和高可用功能。
- 第一个完全支持 ACID 事务的 mysql 存储引擎。

[更多InnoDB特性描述](https://zhuanlan.zhihu.com/p/64180357#:~:text=InnoDB%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1,%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%98%AFREPEATABLE%E3%80%82)

查看某个表具体的引擎信息：```show table status like "table_name" ;```

```shell
mysql> show table status like "sys_admin_user" ;
+----------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+-----------------+----------+----------------+---------+
| Name           | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time         | Update_time | Check_time | Collation       | Checksum | Create_options | Comment |
+----------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+-----------------+----------+----------------+---------+
| sys_admin_user | InnoDB |      10 | Dynamic    |    5 |           3276 |       16384 |               0 |        32768 |         0 |              6 | 2020-06-11 23:02:31 | NULL        | NULL       | utf8_general_ci | NULL     |                |         |
+----------------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+---------------------+-------------+------------+-----------------+----------+----------------+---------+
1 row in set (0.00 sec)
```

> InnoDB和MyISAM 简单比较

MyISAM是MySQL的默认数据库引擎（5.5版之前）。常规特性：

- 全文索引
- 压缩
- 空间函数
- 不支持事务
- 不支持行级锁
- 崩溃后恢复成本很高
- 适用于读密集场所

两者对比：
- MyISAM是表锁(table-level locking)，InnoDB支持行锁(row-level locking)和表锁，锁的粒度越细同等条件下并发性能更高（参考[ConcurrentHashMap](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ConcurrentHashMap%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.md)在jdk1.7和1.8下面的优化设计，1.7分段锁，1.8节点头锁+cas）
- MyISAM相对性能更高，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持（高读低写，但是这种场景我们明显可以使用NoSql相关的数据库代替）。InnoDB 提供事务支持，外部键等高级数据库功能，有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
- 是否支持MVCC ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。

> 索引

- 什么是索引？为什么需要索引？你了解MySQL的索引吗？

其实索引这个概念，我们在日常生活中最常见的例子就是新华字典的使用，我们按照拼音的顺序，可以快速找到我们关注的字的相关解释。

计算机应用程序内有了索引我们可以快速找到需要的应用程序数据。

MySQL的主要的索引有：
- 从数据结构分为：
	- Btree 索引（B+tree，BTree)
	- 哈希索引
	- full-index 全文索引
- 从应用层次分为：
	- 普通索引：即一个索引只包含单个列，一个表可以有多个单列索引。
	- 唯一索引：索引列的值必须唯一，但允许有空值。
	- 复合索引：一个索引包含多个列。
- 从表记录的排列顺序和索引的排列顺序是否一致来划分
	- 聚集索引：表记录的排列顺序和索引的排列顺序一致。
	- 非聚集索引：表记录的排列顺序和索引的排列顺序不一致。

一般来说需要快速的存取数据我们都知道使用固态硬盘，但是在没有固态硬盘之前我们都是使用的机械硬盘，但是我们的MySQL在机械硬盘的情况下也没有掉速特别明显，至少说常规开发使用中无法感知，那么为什么这么快呢？

先简单的说一下我们的磁盘IO相关的信息：

- 磁盘读取数据靠的是机械运动
	- 每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分
	- 寻道时间指的是磁臂移动到指定磁道所需要的时间，一般在5ms以下
	- 旋转延迟则是根据转速决定的，目前主流磁盘转速在7200转/min，1秒钟能转120次，旋转延迟就是1/120/2 = 4. 17ms
	- 传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒（纳秒级别的响应）
- 磁盘IO操作一次的时间约等于：5+4.17 = 9ms，如果磁盘出现小故障则耗时更久
- 我们的计算机指令依靠电传输，也就是说一般来讲一个普通设备，一秒钟内可能发出几十万或者几百万的数据库操作，所以说。。。
- 那么如何提高磁盘的响应效率呢？一般来说就是把某个地址关联的前后数据一起打包出来，在内存中提高响应速度，也就是我们常说的固态硬盘的4k对齐等等。

当然，如果只是在物理层或者操作系统底层去做着一些事情，那么明显的在不同的系统上面我们的MySQL使用体验不可能这么统一，具体是什么让MySQL这么厉害呢？

使用合理的数据结构降低磁盘io开销提高效率。

**BTree**：为磁盘等外存储设备设计的一种平衡查找树，是一种多路搜索树。让系统高效的找到数据所在的磁盘块。先定义一个k-v，假定我们的表只有主键k和其他数据v，不同的数据k不同。

常见的BTree有如下特性：

- 每一个节点最多有 m 个子节点，每个节点不但包含了某些k-v，同时包含了指向下个节点的指针（物理地址，该物理地址下面是存放的某个节点）
- 每一个非叶子节点（除根节点）最少有 ⌈m/2⌉ 个子节点（除根节点和叶子节点外都是分支节点）
- 如果根节点不是叶子节点，那么它至少有两个子节点
- 有 k 个子节点的非叶子节点拥有 k − 1 个键
- 所有的叶子节点都在同一层，每个节点最多可以有m-1个key，并且以升序排列

更加详细的描述看这里：[B-Tree详解](https://www.cnblogs.com/qixinbo/p/11048269.html)

我们知道在数据量足够大的时候，我们不可能直接将数据直接塞入内存中。所以B-Tree在保证高效查找的情况下，还充分利用磁盘扇区的结构，一个节点刚好对应一个磁盘扇区，那么我们需要快速的找到数据，只需要拿到这个数据存放的叶节点（也就是数据区间），然后再到内存中找到命中的数据即可。

**B+Tree**：对BTree的优化，InnoDB存储引擎就是用B+Tree实现其索引结构。

常见B+Tree的特性：

- B +树的每个节点可以包含更多节点
- 将数据范围更改为多个间隔。间隔越大，数据检索越快
- 每个节点不在是存储一个key,而是存储多个key
	- B +树的非叶子节点仅存储key，这样读取某个扇区相对的数据范围更宽，每次IO操作获取数据范围相对BTree更大。
	- 支持更好的范围查找，得益于上一个特性。
	- 叶子节点成对连接，符合磁盘的预读特性。就是说我们在获得了30这个数据的叶子节点，我们30这个节点有32、35这个叶子节点的指针，可以顺序的读取了32、35这个节点，而不需要再去磁盘读写。
	- 数据存放统一在叶子节点，叶子节点都有顺序指向下一个节点的指针，也就是需要范围查询的时候，可以直接在叶子层去操作，降低了对整个树的遍历。
- 叶节点来存储数据，而其他节点用于索引
- 叶子节点通过两个指针相互链接，顺序查询性能更高。

**BTree和B+Tree的区别：**

- B+树中的非叶子节点不存储数据，并且存储在叶节点中的所有数据使得查询时间复杂度固定为log n。
- B树查询时间的复杂度不是固定的，它与键在树中的位置有关，最好是O（1）。
- 由于B+树的叶子节点是通过双向链表链接的，所以支持范围查询，且效率比B树高
- B树每个节点的键和数据是一起的

为什么MongoDB使用BTree？
```
MongoDB主要是以BSON格式(可以认为是JSON)存储的nosql，主要用途为k-v形式的数据操作。
在这种情况下，BTree节点是是键域和数据域的集群，也就是说在某些情况下，一次磁盘IO就可以获取到需要的数据。
```

Hash索引，简单来说就是根据特性的算法找到哈希值，通过哈希值快速查找，速度比BTree和B+Tree快，但是发生hash冲突后处理麻烦（参考Java的hashmap）。

**hash索引和B+Tree的区别：**

- 如果是等价查询，则哈希索引显然具有绝对优势，因为只需一种算法即可找到相应的键值；当然，前提是键值是唯一的,如果存在hash冲突就必须链表遍历了。
- 哈希索引不支持范围查询(不过改造之后可以,Java中的LinkedHashMap通过链表保存了节点的插入顺序,那么也可以使用链表将数据的大小顺序保存起来，虽然支持了范围查询但是时间复杂度是O(n),效率比跳表和B+Tree差)
- 哈希索引无法使用索引排序以及模糊匹配
- 哈希索引也不支持多列联合索引的最左边匹配规则。
- 键值大量冲突的情况下,Hash索引效率极低。

**MySQL支持查询缓存，但是每次缓存都需要额外的开销，缓存数据太久不使用也会销毁。但是在查询条件相同的情况下，不会进行磁盘IO操作，直接在内存中返回结果。如果是在写入密集类型的场景，这种情况下就更加不适合开启查询缓存。**

> MySQL事务，事务是逻辑上的一组操作，要么都执行，要么都不执行。

事务的典型场景就是资金相关的操作，要么成功，要么失败。比如说小明买一个内存需要花费550大洋，首先订单付款环节小明需要扣款550，商家余额需要增加550，那么正确的操作应该是将这两个人的操作放置到同一个事物中，小明和商家的任何一个余额变动异常，则失败，数据都需要回滚到对应的余额上面。

事务的四大特性(ACID)：

- 原子性，事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用，也就是说在上面的资金变动中，小明扣款和商家增加余额都需要保证操作不可分割。
- 一致性，执行事务后，数据库从一个正确的状态变化到另一个正确的状态
- 隔离性，并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的
- 持久性，一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

计算机资源中，任何串行化的操作都能保证顺序的操作，且能够明显降低冲突，但是会导致系统资源的不能合理利用。为了提高资源的合理使用，我们有了并发操作，但是并发操作不能精确的控制会导致一系列的问题。

**并发事务带来哪些问题?**

- 脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
- 不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- 幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

不可重复读的重点是在修改的时候当前事务还没有结束，比如多次读取一条记录发现其中某些列的值被修改。幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。

**事务隔离级别有哪些?MySQL的默认隔离级别是?**

SQL 标准定义了四个隔离级别：
- READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
- REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
- SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。

与 SQL 标准不同的地方在于 InnoDB 存储引擎在 REPEATABLE-READ（可重读） ，**事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生**。这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取提交内容) ，但是你要知道的是InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读） 并不会有任何性能损失。

**InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。**

> mysql锁

mysql常见的锁根据数据粒度分为行锁和表锁。MyISAM采用表级锁(table-level locking)。InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁。

表锁的特点：
- 粒度大，针对某个表锁定
- 速度快，开销低，不会死锁
- 并发性能低
- MyISAM和InnoDB都支持

行锁的特点：
- 粒度小，并发性能高
- 降低表的并发读写冲突
- 加锁开销大，加速慢，并发场景会出现死锁
- Record Lock: 对索引项加锁，锁定符合条件的行，其他事务不能操作
- Gap Lock: 对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。
- Next-key Lock： 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。

推荐使用表锁的场景：
- 数据库表较大时，需要在某个事务中批量操作该表的大量数据，使用表锁效率更高。
- 事务复杂的场景下，行锁若是触发死锁可能引起回滚。

MySQL中锁根据读写类型可分类为：共享锁（s）和排他锁（X）。

**排它锁(X)的简单特点为：**

别名：写锁。事务T对数据对象A添加排它锁后，其他的锁定操作在事务T未结束之前均无效。同时数据A在此时仅仅允许事务T进行操作。**在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁。**


**共享锁(S)的特点为：**

别名：读锁，可以并发读取数据，但任何事务都不能获取数据上的排他锁，直到已释放所有共享锁。

**共享锁和排它锁**的区别主要是：

- 共享锁，只能读取数据。排它锁支持完整的数据的CURD。
- 共享锁，在它锁定数据后，其他数据只能添加共享锁（在这个共享锁的事务未结束之前）。排它锁，在事务中使用排它锁后，其他任何事务均不能在这个事务未结束之前进行锁操作。

既然我们都知道了锁操作，常规的在计算机资源使用过程中，既然有锁定，肯定有可能产生死锁。

**死锁和避免死锁**

死锁是指两个或两个以上事务在执行过程中因争抢锁资源而造成的互相等待的现象。

产生死锁的四个必要条件：

- （1） 互斥条件：一个资源每次只能被一个进程使用。
- （2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- （3） 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
- （4） 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

如何避免死锁？
- 合理设计表索引，避免没有索引的情况下遍历表，这种情况下会导致每行都加锁，死锁产生的概率大大增加。
- 在程序设计中，相同操作数据表或者行范围的事务，尽量都是相同的操作访问顺序。
- 同一个事务尽可能做到一次锁定所需要的所有资源。

> 单表数据量过大如何优化？

- 限制数据查询范围，保证每次查询都合理命中索引。
- InnoDB引擎数据库表，尽量在原索引的基础上扩展索引，单表数据大量的时候新建索引成本可能过高。
- 考虑数据库主从设计，主库写入，从库读取，提高查询性能。
- 根据表数据属性垂直拆分
	- 简单来说就是把多个字段拆分到不同的表中
	- 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。
	- 垂直拆分简化表结构，单表或者关联表它们本身更容易维护。
	- 主键会出现冗余，需要管理冗余列，并会引起Join操作
	- 垂直分区会让事务变得更加复杂
- 根据表数据特性进行某种算法后的分片拆分，水平拆分
	- 表结构不变，数据存放到不同的分区中（类似redis的高可用集群中分片存储思想）。
	- 每一片数据分散到不同的表或者库中，做到了分布式架构。
	- 水平拆分，可以快速大幅度提升系统的吞吐量。
	- 支持超大量数据存放，应用端改造成本较低，但是事务难以解决。
	- 数据分片后，逻辑设计、部署运维等等复杂度明显提升。（在这种情况下，是否需要考虑一下数据需求特性，可否接入其他支持高并发的NoSql相关数据库？）

常见的数据库分片解决方案：

- 客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC （推荐） 、阿里的TDDL是两种比较常用的实现。
- 中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。

分库分表后，id如何设计？

为什么要设计ID？为什么不能使用UUID？如何解决？

常见的额数据库id，一般可以使用自增id，但是在分库分表后，自增id会导致id不可控，严重id冲突，导致数据错乱。

我们前面说过数据库数据读取的时候，BTree和B+Tree合理的使用了磁盘特性，利用磁盘读写的特性，顺序化的数据更利于数据预读。

而UUID是无序的，而且太长，查询效率低下。所以UUID不适合作为数据库主键。

常规的解决办法，核心就是再分布式环境中，算法必须有一致性、互斥性、自增性。通用的解决方案如下：

- 数据库自增ID，多台数据库实例设置不同的步长，逻辑上控制生产不重复ID，这种方式成本高，容易产生性能瓶颈。
- 利用redis生成ID，性能较好，灵活方便，具有原子性能保证绝对唯一。但是引入这种组件会造成系统结构复杂、可用性降低、增加成本。
- 雪花算法，特点就是根据机器本身的特性和系统时钟自增，算法一致性较高，分布式场景下多实例之间不冲突，但是本机时钟回拨会导致单实例ID冲突。
- 美团的Leaf分布式ID生成系统 ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。感觉还不错。美团技术团队的一篇文章：https://tech.meituan.com/2017/04/21/mt-leaf.html 。


> 数据库连接池

什么是连接池？为什么需要使用连接池？你该怎么设计一个简单的连接池？

**这一块的概念，参考Java线程池、redis链接池、我们开放平台内部的链接池设计**

简单特点：
- 快速链接和使用
- 初始状态、使用中状态、池子最大值、异常状态等等的处理。**（我们分布式链接池如何保证关键信息唯一，无锁 -> 方法锁 -> 局部锁+双重检查）**
- 任何一个连接的本质是什么？都需要哪些东西？链接池避免了单链接情况下，重复的开关链接，避免了每次的链接等待，提高了系统关键的并发能力。

#### 拓展

[mysql如何执行SQL](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd)

[高性能MySQL建议](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN#rd)

一个sql执行很慢，如何解决？

- 这个sql偶尔执行很慢
	- 观察这个sql执行时间关联的是不是都执行慢，如果批量变慢，检查一下服务器之间连接稳定性或者数据库服务器在那个时候干了啥，可能是突发性能不够用导致的
	- 在这个时间段，只有它变慢了。检查一下是否刚好遇到脏页刷写（当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。）。
		- 刚好脏页写满了。
		- 内存不够用，导致脏页频繁刷写。
	- 或者就是执行的时候，刚好拿不到锁。只能等待一下，无解。
- 这个sql最近执行变慢了
	- 最近变慢了，先检查数据库服务器整体状态，是否服务器最近状态整体异常。
	- 只有这个sql变慢，其他都正常，这时候检查一下该表整体数据量，统计一下该sql操作的数据区间以及关联的数据区间。
		- 比如说以前的活动都是不温不火，活动记录表还正常，突然来了羊毛党，数据量这几天暴增，导致最近变卡。那么如果说索引最优的情况下，还不能提速，考虑一下业务数据迁移，降低压力。
- 这个sql一直都很慢
	- 首先把复杂的事情简单化，如果sql复杂先把复杂的拆分为简单的。
		- 比如说需要的连表查询拆分出来，根据查询的条件，把关联表的数据直接带入sql。
		- 查看查询的数据数据区间大小，如果说连表查询导致数据区间变大（左链接、右链接、内链接等等），考虑怎么缩小查询的数据区间。
		- 检查sql是否命中索引，不走索引的一些查询，如何尽可能命中合适的索引并且保证索引命中顺序（从左到右，表和sql都需这样）。
		- 检查sql是否执行的时候回表（先通过普通索引定位到主键，再通过主键利用主键索引定位到行，走了多个索引性能下降）。
		- 最后再调整代码层控制查询条件，保证能用到索引，能合理利用索引，关联的关键信息是否需要缓存等等，降低单次查询的数据区间。
	- 检查数据库服务器本身的文件开销，或者说会不会运气不好这个数据库文件刚好在一个坏块上面。

总结一下就是：代码层逻辑清晰，能缓存使用的数据不给数据库增加压力，保证能用到索引，能合理利用索引，降低单次查询的数据区间，保证每次查询的数据库连接稳定，确保数据库服务器正常运转，实在压力太大，引入新的NoSql组件解决问题。