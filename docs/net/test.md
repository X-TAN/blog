#### 网络相关

一般的在计算机网络中，常规分为七层协议和四层协议，其实都是比较类似的，[七层协议](https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B)如下：

- 7、应用层，提供为应用软件而设计的接口，以设置与另一应用软件之间的通信。例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3等。
- 6、表示层，把数据转换为能与接收者的系统格式兼容并适合传输的格式。
- 5、会话层，负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。
- 4、运输层，把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:TCP、UDP等。
- 3、网络层，决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络资料。例如:互联网协议（IP）等。
- 2、数据链路层，负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成信息框（Data Frame）。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（Media access control，MAC）子层。
- 1、物理层，在局部局域网上发送数据帧（Data Frame），它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。

#### 应用层。
> 一般的应用层协议可以使用fiddler或者青花瓷抓包，更加原始底层的数据报文抓包推荐使用wireshark。

主要是用作应用程序间网络通信的接口。对于不同的应用程序，可能的应用层协议不同。

浏览器上网```www.baidu.com```主要的应用协议如下：
- DNS协议，负责将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。
- HTTP协议，超文本传输协议，最初是为了提供一种发布和接收 HTML 页面的方法。

#### 表示层
> 简单来说就是提供数据格式化、编码转换、数据加密等等这一层。比如说我们以前常用的Telnet。

#### 会话层
> 主要是控制A和B之间的通信，负责连接或者解除A和B之间的联系。

**当然上面的这三层，也经常被概括在一起作为五层模型中的应用层。**

#### 运输层

运输层的主要传输的内容统称为数据包，数据包 包含了**传输的具体协议、协议基本信息暴露、协议传输的二进制内容**等等，根据**传输协议可以分为TCP(数据包为 段（segments）)和UDP(数据报（datagrams）)**。

这一层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务。而且这一层在实际中屏蔽了传输过程中对上层展示的具体底层细节。

**比如说我们开放平台基于Rsocket开发的微服务系统，就提供了基于运输层的TCP、UDP连接的服务，这也是为什么我们能比传统http类型的微服务更快的原因。**

#### 网络层

选择合适的网间路由和交换结点，确保数据及时传送。网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。

这一层还有一些路由协议和地 址解析协议（ARP）。有关路由的一切事情都在这第3层处理。地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。

#### 数据链路层（DataLinkLayer)

在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。在这一层，数据的单位称为帧（frame）。数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。

#### 物理层（PhysicalLayer)

规定通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接。实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异， 使其上面的数据链路层不必考虑网络的具体传输介质是什么。

#### 什么是三次握手？

其实面试官问这个问题的时候，更多的是想了解你对这个经典动作“三次握手，四次挥手”的理解。首先必须明确告诉面试官这个是TCP协议的动作（也有人喜欢说HTTP三次握手四次挥手，所有基于TCP传输的协议都有这个动作）。

> 三次握手

简单上图，三次握手：

![三次握手](https://camo.githubusercontent.com/8723eb4a4f807a418ba50748edbe7214c7db2cb2f97ce5038e13e8b6a78fb79b/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545342542382538392545362541432541312545362538462541312545362538392538422e706e67)

- 第一次握手：客户端发送数据包给服务器，在数据包中标明SYN=1（同步序列编号(Synchronize Sequence Numbers)），同时随机生成一个seq（序号 (Sequence Number)，用于标明数据包顺序），客户端进入 SYN-SENT 状态，等待服务器的确认。
- 第二次握手：服务端确认客户端SYN数据包后，返回客户端数据包，并在返回数据包中标明SYN=1、ACK=seq+1、seq=服务端随机数，服务端进入SYN-RECEIVED 状态
- 第三次握手：客户端收到第二次握手时候服务端下发的报文，给服务器返回数据包，数据包中ack=seq+1，seq=第一次握手的seq+1，然后服务器收到报文后，双方进入ESTABLISHED 状态，表示连接已建立。

常规问题：
- 为什么是三次而不是两次或者四次？
	- 三次，可以防止已过期的连接请求报文突然又传送到服务器，因而产生的错误
		- 客户端上送报文A后服务端迟迟没收到报文，客户端重试传输A报文A1，服务端收到A1并且完成流程实现A1的数据传输。
		- 接着客户端的A报文到达服务器，但是相同的A1报文服务器已经处理过，这个报文则被淘汰。
		- 否则服务器再次处理A报文，单方面服务器开销浪费。
	- 三次握手才能让双方均确认自己和对方的发送和接收能力都正常
		- 其实两次握手，客户端已经可以上送报文给服务器了，第一次标明客户端到服务器端正常，第二次标明**服务器到客户端正常（仅仅客户端知道双方正常，服务端仅仅单方面知道客户端OK）**。
		- 但是第三次握手可以让服务端知道客户端和服务端均正常。
	- 确认彼此可靠可信，能进行完整通信
		- TCP能够实现可靠传输原因主要是我们在图中没有标明的seq和ack的具体值状态。
		- TCP维护了每个消息包的序号字段seq和确认序号字段ack，通过这两个可以标明哪些是被对方接受并且处理的。
		- 如果仅仅是两次，那么始终有一方不能得到对方完整的收发状态。

- 为什么只要三次，不是四次或者更多次？
	- 因为三次已经能够完整的了解彼此的完整收发状态，再多次仅仅是资源的浪费，并无其他收益。

- 你了解三次握手过程中的网络攻击吗？
	- 三次握手，主要是需要双方确认后建立连接，其实简单来说第二次握手的时候，服务器已经是连接就绪状态，只是说等待客户端再次确认开始收数据。这种时候，服务器状态为：连接半开。
	- 也就是客户端仅仅进行第一次握手，实现程序短时间大量发送第一次握手的报文，服务器就会有大量的半开状态连接，一旦这个连接数超过系统的承载能力，服务器就会拒绝提供后续的连接服务。俗称SYN攻击或者说是DDOS攻击。
	- 解决办法：
		- 降低半开连接的等待时间，快速淘汰半开链接，当然间隔太短可能导致客户端在网络波动剧烈情况下体验很差。
		- 维护一个类似连接缓冲区的东西，根据客户端第一次握手数据包的关键信息（主要是客户端信息），通过某种固定的散列算法（足够大，降低冲突），将这些信息缓存到内存中，这时候不能创建连接。当收到第三次握手再分配资源创建连接。
	
> 四次挥手

TCP本身是一个全双工的连接，双方可以随时互通有无，也就是说这个连接是双方同时维持的，最少是必须知道彼此双方的IP+端口，在这种模式下要关闭TCP连接，双方必须都关闭才是合理的。所以就需要通知到双方都确认需要关闭才行。

![四次挥手](https://image-static.segmentfault.com/748/605/748605951-5e7b1e45d431b)

- 第一次挥手：客户端数据传输完毕后，发送一个数据包通知服务端准备关闭连接，停止使用这个连击传输数据。这个数据包包含：FIN 标志位1，序号字段 seq = x (等于之前发送的所有数据的最后一个字节的序号加一)，然后客户端会进入 FIN-WAIT-1 状态，等待来自服务器的确认报文。
- 第二次挥手：服务器收到 客户端的FIN 报文后，发回确认报文。这个服务器发送的数据包ACK标志位 = 1， ack = x + 1，并带上自己的序号 seq = y，然后服务器就进入 CLOSE-WAIT 状态。上层应用这边是已经明白客户端已经释放连接。服务器端的TCP处于半关闭状态，上层应用不需要再接收数据。
	- 客户端收到服务器的 ACK 报文段后随即进入 FIN-WAIT-2 状态，此时还能收到来自服务器的数据，直到收到 来自服务器的FIN 报文段（第三次挥手）。
- 第三次挥手：服务器端发送完所有数据包后，再给客户端发送FIN报文，此时报文数据中包含：FIN 标志位=1，ACK标志位 = 1， ack = x + 1，seq=z。服务器接着进入LAST-ACK 状态，等待来自客户端的确认报文段。
- 第四次挥手：客户端收到来自服务器的 FIN 报文段后，向服务器发送 ACK 报文，随后进入 TIME-WAIT 状态，等待 2MSL(2 * Maximum Segment Lifetime，两倍的报文段最大存活时间) ，这是任何报文段在被丢弃前能在网络中存在的最长时间，常用值有30秒、1分钟和2分钟。如无特殊情况，客户端会进入 CLOSED 状态。
	- 服务器在接收到客户端的 ACK 报文后会随即进入 CLOSED 状态，由于没有等待时间，一般而言，服务器比客户端更早进入 CLOSED 状态。

常规问题：
- 为什么 TCP 关闭连接为什么要四次而不是三次？
	- 我们常规了解到的数据报文发送基本上都是 请求<->响应。也就是说客户端发了FIN，服务端必须回复ACK，但是这个时候客户端并不能确定 服务端 的数据是否都传输完毕了，所以需要 服务端发送FIN给客户端标明 数据全部发送完毕了，客户端收到FIN后回复ACK标明数据接收完毕，此时双方都能安全关闭连接。
	- 前两次挥手，能清晰的标明客户端数据发送完毕，但是不能保证服务端数据传输完毕，同时只是服务端单方面感知到客户端状态，客户端不能知道服务器状态。
	- 第三次挥手，明确告诉客户端服务器端的状态，也确认了数据发送完毕。
	- 第四次挥手，客户端标明数据完全接受到了，服务器收到这个数据包后，双方对于这个数据传输处理的过程均已经明确结束，此时双方能安全合理的关闭连接，保证了数据传输的安全性和完整性。

- 客户端为什么需要在 TIME-WAIT 状态等待 2MSL 时间才能进入 CLOSED 状态？
	- 首先明确：网络传输不是始终可靠，在这种情况下，如果需要确认数据传输ok，始终需要问询。就像我们在买东西的时候，问老板有没有东西、问老板有没有收到钱，然后老板给的对应回复我们才能完整的买到东西走人。
	- 如果客户端没有及时的回复 第三次挥手 的报文，服务端会不断下发 第三次挥手。为了解决这个传输中的问题，我们需要必须的一点点等待，就像是买东西老板那边人多需要时间处理一样。
	- 在等待时间内没有收到其他的报文，说明我们这个连接需要做的事情已经都结束了，可以安全关闭。

#### TCP和UDP的区别

|协议类别|是否面向连接|传输可靠性|传输形式|传输效率|资源开销|场景|首部字节长度|
|--|--|--|--|--|--|--|--|
|TCP|面向连接|相对可靠传输|字节流|效率相对较低|资源开销相对较大|可靠传输场景|20-60|
|UDP|无|相对不可靠|数据报文段|效率相对较高|资源开销相对较小|快速传输，无需确认|8|

UDP只需要丢出去，不需要建立完整传输管道，也不需要保证接收，也不需要确认。UDP只需要明确目标IP和端口就行，提供广播或者多播能力，局域网广播：255.255.255.255:端口

TCP面向连接，可靠传输，必须收发方相互确认后，才能保证可靠，无广播无多播。在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。

#### TCP 协议如何保证可靠传输

- 应用数据被分割成 TCP 认为最适合发送的数据块。
- TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
- 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
	- 简单来说，在不可信传输中，我们传输文件可以通知客户端这个文件的特定算法校验结果，如果说这个文件的校验结果不通过，则丢弃这个文件。
	- 也可以 使用特定算法校验响应的数据是否被篡改（更直接保险就是直接响应数据加密）。
- TCP 的接收端会丢弃重复的数据。
- 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
	- 流量控制是为了控制发送方发送速率，保证接收方来得及接收。
	- 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。（这里可以提一下，我们语音开放平台SDK中集成了二进制数据传输包检查，在包头中传输了客户端到服务端ping-pong延迟时间，通过这个控制服务端下发速率）。
- 拥塞控制： 当网络拥塞时，减少数据的发送。
	- 在网络传输中，网络链路不是百分百可靠，当这个链路某段部分某时刻负荷较大，网络性能可能会下降，这就是网路拥塞。
	- 拥塞控制是为了保护数据不会过量，保护链路整体，也就是某个环节出现问题，则整个链路上面性能最大能力就是这个最差环节，木桶的短板效应。
	- 流量控制是点对点通信量的控制，是个端到端的问题，抑制发送端发送数据的速率，以便使接收端接收正常。
	- TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。
	- TCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。
		- 慢开始：就是网络传输刚开始的时候，彼此都不知道链路性能怎么样，可以有小到大的发送数据包探测，cwnd初始值为1，每经过一个传播轮次，cwnd加倍。
		- 拥塞避免：拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.
		- 快重传与快恢复：能快速恢复丢失的数据包，当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作（这时候，肯定链接传输失败，重新全部发送就行了）。
- ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
- 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

#### HTTP和HTTPS，长连接和短连接

**HTTP 和 HTTPS 的区别？**
- 端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。
- 安全性和资源消耗：
	-  HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。也就是传输过程中，数据可以被随意修改，如果双方没有严格的校验检查，数据完全不可信。
	-  HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。
	-  HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。
	-  对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；
	-  非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。

**长连接和短连接**

常见的比较就是普通http请求和websocket连接：
- http是常见的短连接，用完则关闭（在1.1中引入了长连接概念，请求头标明1.1，并且加入Connection:keep-alive，这样可以连接重用）。
- websocket本身是基于http的get请求进行拓展，双方握手成功后，服务端给客户端发送 101，并且响应头部塞入：```Upgrade:websocket```和```Connection:Upgrade```，具有完整的socket特性，双工，支持pingpong机制，支持文本和二进制数据包传输。
- **在我们的到端的sdk中，如果探测到长连接延迟很大的情况下，音频数据的传输会切换成分片的http传输，降低长连接链路的压力，但是音频识别结果还是会直接推送给长连接。**



