#### MQ理解，主要基于RabbitMQ

##### 为什么使用MQ

MQ简单来说是消息队列，特性跟队列一样：**先进先出**。

在我看来，**应用程序引入外部组件，都是为了解决问题**，而不是引入问题，使用MQ主要场景大部分均是：**解耦、异步、流量削峰**。

> 解耦

解耦，就是为了降低各个系统之间的耦合，在单机应用的时候，所有资源集中处理，深度耦合。在微服务化后端项目的时候，就是需要把原先单个jvm虚拟机内的数据，通过某种传输方式改变成另外的jvm（单个或者多个）可以识别的数据。

数据交换一般的手段：

- 文件（存放内容大，支持快速获取部分内容（文件分段读取），但是不能实时让其他系统处理）
- 网络请求（能实时处理，但是不能太大量数据）

在这种情况下，我们**微服务化项目，就是把某些功能模块调整成使用网络通信交换数据的程序（不再局限于实现语言，专注于数据协议标准对接）**。

我们知道了单个服务解耦成为微服务，服务之间调用都通过网络请求。

那么在我这个A服务需要调用B、C、D、E这么多个服务呢？这个功能的研发人员，需要去关注多个其他模块，导致整个系统严重耦合。

在业务场景许可的情况下，我们可以采用MQ解耦微服务之间的关系，达到一次请求高速响应的关系。且这种时候，我只需要关注自身能提供的数据协议，其他地方快速对接，不再需要人肉调试，降低程序耦合，降低研发成本。

> 异步

在我们的开放平台中，智能语音处理，需要的是将音频数据丢给三方或者是云部署的模型，在这种情况下，什么时候能处理完音频数据是未知的。

在我们第一版本的时候，采用了kotlin的channel通知形式，但是在大量的语音识别请求下，kotlin的channel会导致阻塞我们的rsocket链接。

后面我们使用mq，当我们处理完音频数据的时候，我们直接将消息通知到网关（语音识别消息入口），降低了结果在多个服务之间穿梭，同时解除了识别服务和网关服务之间的同步压力，采用异步实时响应的形式通知到客户端。（此处可以讲一下，我们为什么用RabbitMQ，主要还是RabbitMQ的延时最低，我们语音处理就是要快人一步，我们开放平台后续是去中心化的broker+多云部署+跨云部署）

> 流量削峰

在典型的系统对账场景，我们一天可能有千万笔订单，这个时候我们简单的对账完毕后，再刷回数据库，首先这个量的数据一次次的刷，压力太大。另外就算DB这个时候能抗住，如果这个时候我们平台有活动，突然流量激增，这么大的流量过来，系统一时半会也是难以承受。

这种情况下，我们的落地场景可以针对数据分级，优先级高的数据优先写入，通过缓存+mq等等手段控制流量峰值，同样的其他的数据可以提交到一些其他的任务池中，根据系统压力或者人工干预的情况下再回落数据库。

##### 消息队列的缺点

任何一个应用程序，我们的目标都是让应用程序更加健壮，越多的三方组件引入，越容易导致系统的不稳定。所以显著的缺点有：**系统复杂度提高**。

用了mq过后，我们还要根据mq的特性考虑，我们这个mq是不是会挂掉？MQ掉线如何处理？那么缺点又是：**系统可用性降低**。

关键还有我们前面讲过的消息可以异步处理，那么问题来了，比如说订单消费结果需要强一致，在这种情况下如果订单消息需要多个系统共享，那么如何保证我们消息投放OK，如何保证消费处理问题，如何保证多系统数据一致问题？或者说某些开发人员收到消息就确认了，但实际上还没处理。**如何保证一致性呢**？


#### 各个MQ对比

|特性|ActiveMQ|RabbitMQ|RocketMQ|Kafka|
| -- | -- | -- | -- | -- |
|单机吞吐量|万级|万级|10万级别，高吞吐|10w级别，高吞吐，可用于日志收集、实时计算等场景|
|时效性|ms级别|微秒级别，超低延迟|ms级别|ms级别|
|可用性|高可用，基于主从|高可用，基于主从|高可用，分布式架构|高可用、分布式、一个数据多个副本，不丢数据|
|消息可靠性|可能丢失数据|基本不会丢|可配置不丢失|可配置不丢失|
|功能特性|待完善|待完善|待完善|待完善|

##### 如何设计高可用MQ

> RabbitMQ

主从设计模式的高可用。三种模式：单机、普通集群、镜像集群

**单机模式：无法做到高可用，仅用于研发或者测试阶段。**

普通集群：**无法做到绝对的高可用，相对可用性不错**。特点：多机器、多MQ，但是手动创建的MQ的信息在某个实例上面，他们通过同步这些元素实现其他mq存有信息。**未实现分布式**，单机性能跟不上的时候，影响整个集群。或者说单机挂了，可能消息无法复制到了，GG。

镜像集群模式：**高可用。这种模式下，所有的数据都会存放到多个MQ上面，每个MQ都有个完整镜像。会自动同步消息到每个queue上面。**

> Kafka的高可用性

Kafka：由多个broker组成，类似我们的开放平台，每个broker都是一个节点，创建一个topic，这个topic划分为多个partition，可以分布到不同的broker上，每个partition可以放一部分数据。可以理解成，我们的开放平台有多个broker控制的节点，每个节点处理对应的数据，可以协同工作。
 RabbitMQ的消息队列就是传统的单击项目，只不过在镜像模式下面，每个RabbitMQ存有完整的数据。

在Kafka 0.8 以后提供了副本机制，每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。**这个就类似我们的本地会议宝，自动组网后通过udp选举一个leader，所有数据通过leader进行交换。**那么我们的 partition数据有多个复制实例，当其中一个broker掉线，其他的通过选举leader后还能提供服务。

**写数据**的时候，数据写入leader的磁盘，然后其他的会把数据pull出来，完成后给leader发送ACK标志，收到所有的ack就能写入成功。**消费数据**的时候，只会经过leader，但是其他follower都返回ACK标志确认后，这个消息才会被读取。

#### 如何不会重复消息？怎么避免重复消费？

这个问题本质是：**如何保证消息队列的幂等性**。

在RabbitMQ中，消息幂等这个只需要我们在代码层做到：需要使用的地方消费，消费结束后发送确认ACK。常见的比如说订单：我们订单场景，状态同步的时候，我们通过分布式锁保证状态幂等，处理成功后，回归给MQ一个确认的ACK即可。当重复的消息到达后，我们只需要检查这个状态是否匹配，或者说在订单状态中维护一个版本号，通过版本号和状态等等淘汰旧的数据。

#### 如何保证消息不丢

> 消费过程中代码上层的消息确认（上层代码的发送和消费）

在RabbitMQ中，我们可以通过消息的确认模式来确保消息不丢，在写入消息的时候会产生一个唯一ID，如果写入成功则会有一个确认的ACK，否则会调用NACK接口通知消息失败，这时可以充重试。同时下游可以收到确认通知给上游，如果在一定时间还没收到消息的确认，可以重发消息。如果说使用事务提交，则会产生大量的事务阻塞。

如果说在消费端收到消息没处理的一瞬间挂逼，这个时候还是上面一个手动消费再ACK，否则MQ会把消息丢给其他的consumer处理。

> 在开启了消息持久化的MQ上面消息丢了如何搞？

- 持久化queue
- 第二个是发送消息的时候将消息的 deliveryMode 设置为 2

同时配置了这两个，会强制刷写数据进入磁盘，重启MQ后，消息还在的，但是如果说还有消息丢失，就需要上层控制消息检查，多重机制保证消息。


#### 消息顺序保证

一般来说，压力不是特别大的情况下，都是先进先出。但是可能开发人员在开发的时候把多个queue的东西绑定到同一个consumer上面，可能会导致看到的表现是消息乱序，这时候最好的解决办法就是分开，各用个的queue和对应的consumer。

#### 消息堆积如何处理？

消息堆积，一般来说就是要么不消费，要么消费速度远远小于生产速度。

出现这种问题，首先第一件事检查消费端，看看是不是程序异常停掉了，如果说是这种情况，肯定先排查错误原因紧急修复一下恢复消费能力。如果是消费速度过慢，说明消费者内部可能出现什么异常，比如说数据库堵塞、程序内部死锁等等这种一般需要先紧急修复问题，然后灰度上线恢复消费速度，再将故障端停掉。
或者说先上线多个消费端，提升消费速度，等恢复后，再关闭多余的消费端，最重要还是保证程序自身不出现故障。

#### MQ消息过期了，导致消息丢失
在这种情况下，就是我们上面所说的消息都需要有一些副本存放，比如说落到redis中，经过基线检查发现消息都没有被正常消息，这个时候需要人工干预恢复业务数据。

#### 如何设计消息队列？

这个还是站在程序设计的原则上面来讲，首先我们需要保证程序功能完善、程序健壮。

功能完善，比如说我们这个消息队列对接哪些协议，需要达到的各项指标。

程序健壮，那么基本上就是高可用的那种玩法：

- 可伸缩，能快速扩容。比如说kafka，broker -> topic -> partition ，每个partition存放到不同的机器，各自存放一部分数据，容量不够就加机器自动化数据迁移。
- 持久化，任何程序都不能百分百保证不出故障，那么在这个时候我们的持久化策略就很重要，在什么时候落地到磁盘，怎么在保证数据正常读写的时候，还能落地到磁盘，而且怎么样支持高速的磁盘读写（可以参考mysql的数据结构b+树）？
- 高可用，如何在某个节点掉线后，能够快速的恢复？基本上就是自组网，快速恢复leader这种玩法。
- 0丢失？